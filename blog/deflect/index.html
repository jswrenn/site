<!DOCTYPE HTML>
<html>
    <head>
        <title>Native Reflection in Rust</title>
        <meta name="author" content="Jack Wrenn" />
        <link rel="author" href="https://jack.wrenn.fyi/">

        
<meta name="twitter:title" content="Native Reflection in Rust" />
<meta name="twitter:description" content="" />


        
          <link rel="alternate" type="application/atom+xml" title="Atom" href="https://jack.wrenn.fyi/atom.xml">
        

        <meta property='og:type' content='article' />
        <meta property='article:author' content='https://jack.wrenn.fyi/' />
        <meta property='article:publisher' content='https://jack.wrenn.fyi/' />
        <meta property='og:site_name' content='Jack Sometimes Writes' />
        
        <meta name="twitter:card" content="summary" />
        <meta name="twitter:site" content="@tenellous" />
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
        <style>
            html {
              margin: 0em;
              font-size: 16px;
              font-size: min(max(1rem, 4vw), 16px);
              font-family: serif;
              line-height: 1.45;
            }
            
            body {
              margin: 0 auto;
              padding-right: 1em;
              padding-bottom: 1em;
              max-width: 50em;
              overflow-x: hidden;
            }

            main {
              margin: 0 0.5em;
            }

            section {
              border: .2em black dotted;
            }

            article {
              padding: 1em;
            }

            article.preview {
              padding: 0 1em;
              margin-bottom: 1em;
              border: .2em black dotted;
              box-shadow: 1em 1em rgba(0,0,0,0.1);
            }

            code {
              font-size: 80%;
              background-color: rgb(0 0 0 / 10%)
            }

            .twitter-tweet:not(.twitter-tweet-rendered),
            pre > code {
              border: .2em black dotted;
              box-shadow: 1em 1em rgba(0,0,0,0.1);
            }

            pre {
              display: flex;
              max-width: calc(100vw - 2em);
              font-size: 0.9em;
              position: relative;
              left: 50%;
              right: 50%;
              margin-left: calc(-50vw + 1em);
              margin-right: calc(-50vw - 1em);
              background-color: transparent!important;
            }

            .twitter-tweet:not(.twitter-tweet-rendered),
            pre > code {
              margin: 0 auto;
              padding: 1em;
              max-width: 100vw;
              overflow: auto;
              background-color: white;
            }

            header > h1 {
              margin-bottom: 0;
            }
            
            main > section {
              border: .2em black dotted;
              padding: 1em;
              padding-top: 0;
            }

            h1 > a, h2 > a, h3 > a {
              color:black!important;
              text-decoration:none;
            }

            h1 > a:hover, h2 > a:hover, h3 > a:hover {
              text-decoration:underline;
            }

            table {
              width: 100%;
            }

            th {
              border-bottom: 4px black solid;
            }

            .language-rust_errors .warning {
              color: #f79a06
            }

            .language-rust_errors .error {
              color: #bf1b1b
            }

            .twitter-tweet {
              margin: 0 auto;
            }

            img {
              display: block;
              margin: 0 auto;
              max-width: 100%;
            }
        </style>
    </head>

    <body itemtype="http://schema.org/WebPage">
        <link itemprop="mainEntityOfPage" href="https://jack.wrenn.fyi/blog">
        <header>
          <h1 itemprop="name">
            <span itemid="#author" itemscope itemprop="author publisher" itemtype="http://schema.org/Person">
              <meta itemProp='name' content='Jack Wrenn' />
              <a itemprop="url" href="/">Jack</a>
            </span> <a id="masthead" itemprop="url" href="/blog">Sometimes Writes</a></h1>
        </header>
        <main itemscope itemtype="http://schema.org/Blog">
          <link itemprop="mainEntityOfPage" href="https://jack.wrenn.fyi/blog">
          
<article itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    <h1 itemprop="headline">Native Reflection in Rust</h1>
    <time itemprop="datePublished" datetime="2022-12-15">
      2022-12-15
    </time>
    <link itemprop="author publisher" itemtype="http://schema.org/Person" href="#author"/>
  </header>
  <div itemprop="articleBody">
    <p>Today, I’m releasing <em><strong>deflect</strong></em>, an implementation of <a href="https://en.wikipedia.org/wiki/Reflection">reflection</a> for Rust. Deflect can be used to recover the concrete types of trait objects, inspect the internal state of <code>async</code> generators, pretty-print arbitrary data, and much more.</p>
<span id="continue-reading"></span>
<p>Here are the crate’s important links:</p>
<ul>
<li><a href="https://crates.io/crates/deflect">https://crates.io/crates/deflect</a></li>
<li><a href="https://docs.rs/deflect">https://docs.rs/deflect</a></li>
<li><a href="https://github.com/jswrenn/deflect">https://github.com/jswrenn/deflect</a></li>
</ul>
<h2 id="what">What?</h2>
<p>Reflection is the ability of a program to inspect its own structure and behavior. In Javascript, for example, it’s possible (and quite common) to write programs that iterate over the key–value pairs of arbitrary objects, or check that an object contains a field of a given name. Deflect brings some of these capabilities to Rust.</p>
<p>At the heart of deflect is its <code>Reflect</code> trait, which is implemented for all types. With it, you can:</p>
<ul>
<li>recover the concrete type of any trait object</li>
<li>index-by-name or iterate-over the fields of a <code>struct</code></li>
<li>examine the captured data of a closure</li>
<li>examine the internal structure of Rust <code>async fn</code> generators</li>
<li>pretty-print arbitrary data (even if it doesn’t implement <code>Debug</code>!)</li>
</ul>
<p>Here is an example showing off a few of these capabilities:</p>
<pre data-lang="rust" style="background-color:#ffffff;color:#4d4d4c;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#999999;">// define a datatype
</span><span style="color:#999999;">// note that it doesn&#39;t `derive` any traits
</span><span style="color:#8e44be;">struct </span><span>Foo {
</span><span>    </span><span style="color:#f55800;">a</span><span>: </span><span style="color:#8e44be;">u8
</span><span>}
</span><span>
</span><span style="color:#999999;">// initialize the reflection info provider
</span><span style="color:#8e44be;">let</span><span> context </span><span style="color:#1aa7b0;">= </span><span>deflect::default_provider()</span><span style="color:#1aa7b0;">?</span><span>;
</span><span>
</span><span style="color:#999999;">// create some type-erased data
</span><span style="color:#8e44be;">let</span><span> erased: </span><span style="color:#f0ae00;">Box</span><span>&lt;dyn Any&gt; </span><span style="color:#1aa7b0;">= </span><span style="color:#f0ae00;">Box</span><span>::new(Foo { a: </span><span style="color:#6969ff;">42 </span><span>});
</span><span>
</span><span style="color:#999999;">// cast it to `&amp;dyn Reflect`
</span><span style="color:#8e44be;">let</span><span> reflectable: </span><span style="color:#1aa7b0;">&amp;</span><span>dyn deflect::Reflect </span><span style="color:#1aa7b0;">= &amp;</span><span>erased;
</span><span>
</span><span style="color:#999999;">// reflect it!
</span><span style="color:#8e44be;">let</span><span> value: deflect::Value </span><span style="color:#1aa7b0;">=</span><span> reflectable.</span><span style="color:#3366cc;">reflect</span><span>(</span><span style="color:#1aa7b0;">&amp;</span><span>context)</span><span style="color:#1aa7b0;">?</span><span>;
</span><span>
</span><span style="color:#999999;">// pretty-print the reflected value
</span><span style="color:#999999;">// note that the concrete type `Foo` has been recovered from `dyn Any`!
</span><span>assert_eq!(value.</span><span style="color:#3366cc;">to_string</span><span>(), </span><span style="color:#699200;">&quot;box Foo { a: 42 }&quot;</span><span>);
</span><span> 
</span><span style="color:#999999;">// downcast into a `BoxedDyn` value
</span><span style="color:#8e44be;">let</span><span> value: deflect::value::BoxedDyn </span><span style="color:#1aa7b0;">=</span><span> value.</span><span style="color:#3366cc;">try_into</span><span>()</span><span style="color:#1aa7b0;">?</span><span>;
</span><span>
</span><span style="color:#999999;">// dereference the boxed value
</span><span style="color:#8e44be;">let</span><span> value: deflect::Value </span><span style="color:#1aa7b0;">=</span><span> value.</span><span style="color:#3366cc;">deref</span><span>()</span><span style="color:#1aa7b0;">?</span><span>;
</span><span> 
</span><span style="color:#999999;">// downcast into a `Struct` value
</span><span style="color:#8e44be;">let</span><span> value: deflect::value::Struct </span><span style="color:#1aa7b0;">=</span><span> value.</span><span style="color:#3366cc;">try_into</span><span>()</span><span style="color:#1aa7b0;">?</span><span>;
</span><span> 
</span><span style="color:#999999;">// get the field `a` by name
</span><span style="color:#8e44be;">let </span><span style="color:#f0ae00;">Some</span><span>(field) </span><span style="color:#1aa7b0;">=</span><span> value.</span><span style="color:#3366cc;">field</span><span>(</span><span style="color:#699200;">&quot;a&quot;</span><span>)</span><span style="color:#1aa7b0;">? </span><span style="color:#8e44be;">else </span><span>{
</span><span>    panic!(</span><span style="color:#699200;">&quot;no field named `a`!&quot;</span><span>)
</span><span>};
</span><span> 
</span><span style="color:#999999;">// get the value of the field
</span><span style="color:#8e44be;">let</span><span> value: deflect::Value </span><span style="color:#1aa7b0;">=</span><span> field.</span><span style="color:#3366cc;">value</span><span>()</span><span style="color:#1aa7b0;">?</span><span>;
</span><span> 
</span><span style="color:#999999;">// downcast into a `u8`
</span><span style="color:#8e44be;">let</span><span> value: </span><span style="color:#8e44be;">u8 </span><span style="color:#1aa7b0;">=</span><span> value.</span><span style="color:#3366cc;">try_into</span><span>()</span><span style="color:#1aa7b0;">?</span><span>;
</span><span> 
</span><span style="color:#999999;">// check that it&#39;s equal to `42`!
</span><span>assert_eq!(value, </span><span style="color:#6969ff;">42</span><span>);
</span></code></pre>
<h2 id="how">How?</h2>
<p>Other notable implementations of reflection for Rust include <a href="https://crates.io/crates/bevy_reflect">bevy_reflect</a> and <a href="https://crates.io/crates/frunk">frunk</a>. These crates provide reflection traits that can be <em>explicitly</em> implemented for particular types, usually via a proc-macro <code>derive</code>. They are reliable, featureful crates that leverage and complement Rust’s linguistic facilities. These crates are suitable for any use case where you know in advance which types you’ll need to reflect.</p>
<p>Like these other crates, deflect <em>also</em> defines a reflection trait. However, deflect’s trait is implemented for <em>all</em> types. Yes, all of them. The entire definition looks like this:</p>
<pre data-lang="rust" style="background-color:#ffffff;color:#4d4d4c;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#999999;">/// A reflectable type.
</span><span style="color:#8e44be;">pub trait </span><span>Reflect {
</span><span>    </span><span style="color:#999999;">/// Produces an ID that uniquely identifies the type in its compilation unit.
</span><span>    #[</span><span style="color:#f55800;">inline</span><span>(never)]
</span><span>    </span><span style="color:#8e44be;">fn </span><span style="color:#3366cc;">local_type_id</span><span>(</span><span style="color:#1aa7b0;">&amp;</span><span style="color:#6969ff;">self</span><span>) -&gt; </span><span style="color:#8e44be;">usize </span><span>{
</span><span>        </span><span style="color:#1aa7b0;">&lt;</span><span style="color:#8e44be;">Self </span><span style="color:#1aa7b0;">as</span><span> Reflect</span><span style="color:#1aa7b0;">&gt;</span><span>::local_type_id </span><span style="color:#1aa7b0;">as </span><span style="color:#8e44be;">usize
</span><span>    }
</span><span>}
</span><span>
</span><span style="color:#999999;">// Implement `Reflect` for ALL types.
</span><span style="color:#8e44be;">impl</span><span>&lt;T: ?Sized&gt; Reflect for T {}
</span></code></pre>
<p>So how does deflect know anything about the internal structure of Rust types?</p>
<p>In a sense, it pretends it’s a native debugger like <a href="https://www.sourceware.org/gdb/">GDB</a> or <a href="https://lldb.llvm.org/">LLDB</a> — it leverages <a href="https://en.wikipedia.org/wiki/DWARF">DWARF</a> debug info, emitted by rustc, to interpret the structure of Rust data.</p>
<p>When you call <code>.reflect</code> on a <code>dyn Reflect</code> value, deflect figures out its concrete type in four steps:</p>
<ol>
<li>invokes <code>local_type_id</code> to get the memory address of your value’s static implementation of <code>local_type_id</code></li>
<li>maps that memory address to an offset in your application’s binary</li>
<li>searches your application’s debuginfo for the entry describing the function at that offset</li>
<li>parses that debugging information entry (DIE) to determine the type of <code>local_type_id</code>’s <code>&amp;self</code> parameter.</li>
</ol>
<p>The DIE of the <code>Self</code> type has information about the kind of the type (struct, enum, pointer, primitive, etc.), its size, alignment, and the locations and types of its fields. With all this, deflect is able to dynamically reflect the structure of your value’s bytes.</p>
<p>In a future blog post, I’ll write about how deflect also determines the concrete types of <code>dyn Trait</code> objects where the trait <em>doesn’t</em> have a <code>local_type_id</code> method. I think the approach could be useful to native debuggers, like GDB and LLDB.</p>
<h2 id="why">Why!?</h2>
<p>Last October, I <a href="https://tokio.rs/blog/2022-10-announcing-async-backtrace">released async-backtrace</a>, a crate for partially reflecting the logical structure of idle asynchronous tasks. Like <a href="https://crates.io/crates/bevy_reflect">bevy_reflect</a> and <a href="https://crates.io/crates/frunk">frunk</a>, async-backtrace relies on proc-macro magic to produce its backtraces. Its traces <em>only</em> include functions annotated with <code>#[async_backtrace::framed]</code>; e.g.:</p>
<pre data-lang="rust" style="background-color:#ffffff;color:#4d4d4c;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#999999;">// included in traces
</span><span>#[</span><span style="color:#f55800;">async_backtrace</span><span>::</span><span style="color:#f55800;">framed</span><span>]
</span><span>async </span><span style="color:#8e44be;">fn </span><span style="color:#3366cc;">foo</span><span>() {
</span><span>    </span><span style="color:#3366cc;">bar</span><span>().await;
</span><span>}
</span><span>
</span><span style="color:#999999;">// NOT included in traces
</span><span>async </span><span style="color:#8e44be;">fn </span><span style="color:#3366cc;">bar </span><span>() {}
</span></code></pre>
<p>Predictably, few people relish the prospect of annotating <em>every</em> single async function in their codebase — to say nothing of annotating async functions in the crates they depend on!</p>
<p>It was around this time that I learned that <a href="https://github.com/tmandry">Tyler Mandry</a> was <a href="https://rust-lang.zulipchat.com/#narrow/stream/187312-wg-async/topic/Async.20stack.20trace.20support.20library/near/306350471">experimenting with DWARF-directed async backtraces</a>, capable of providing traces of arbitrary <code>async fn</code>s! His proof of concept was compelling, but generalizing it to <em>arbitrary</em> <code>Future</code>s (particularly, manually-implemented ones) would require the ability to reflect <em>arbitrary</em> types. Thus, deflect was born.</p>
<h2 id="caveats-abound-contributors-needed">Caveats Abound, Contributors Needed</h2>
<p>Deflect, today, is a compelling, albeit unpolished, proof-of-concept. It is capable of reflecting over nearly all compositions of Rust types, but caveats abound. To name a few:</p>
<ul>
<li>It only works if DWARF debug info is packed into the application’s binary.
<ul>
<li>It does not <em>yet</em> work on macOS, which splits debug info into other files.</li>
<li>It may never work on Windows, which does not use DWARF to encode debug info.</li>
</ul>
</li>
<li>It does not <em>yet</em> specially handle the presence of <code>UnsafeCell</code>, which can lead to unsoundness.</li>
<li>I am dissatisfied with how Rust’s many reference types are currently reflected. Deflect must accurately mimic the nuances of field projection in Rust.</li>
<li>How rustc encodes debug info is subject to change over time, and this crate only reflects rustc’s conventions on a best-effort basis.
<ul>
<li>Relatedly, this crate needs to be tested against a far greater variety of Rust types!</li>
</ul>
</li>
</ul>
<p>I need help with all these challenges, and more!</p>
<h2 id="finally-thanks">Finally, Thanks</h2>
<p>Kudos to Tyler Mandry and Michael Woerister for their time, ideas and expertise. And, thanks to my employer, the Rust Platform Team at AWS, for supporting this work. I’m endlessly grateful to have the freedom and opportunity to push the bounds of what’s possible in Rust.</p>

  </div>

  <hr/>
  Email comments and corrections to <a href="mailto:jack@wrenn.fyi">jack@wrenn.fyi</a>.
</article>

<footer>
  <a href="https://twitter.com/tenellous">Follow me on Twitter!</a>
</footer>


        </main>
    </body>
</html>